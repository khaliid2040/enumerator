diff --git a/Makefile b/Makefile
index aea2e50..60b934a 100644
--- a/Makefile
+++ b/Makefile
@@ -17,7 +17,8 @@ EXECUTABLE = systeminfo
 
 # Object files
 OBJ_FILES = main.o \
-			$(OBJ_DIR_EXTRA)/process.o $(OBJ_DIR_EXTRA)/utils.o $(OBJ_DIR_EXTRA)/desktop.o $(OBJ_DIR_EXTRA)/security.o $(OBJ_DIR_EXTRA)/packages.o\
+			$(OBJ_DIR_EXTRA)/process.o $(OBJ_DIR_EXTRA)/utils.o $(OBJ_DIR_EXTRA)/desktop.o \
+			$(OBJ_DIR_EXTRA)/security.o $(OBJ_DIR_EXTRA)/packages.o $(OBJ_DIR_EXTRA)/shell.o \
 			$(OBJ_DIR_NET)/network.o $(OBJ_DIR_NET)/arp.o $(OBJ_DIR_NET)/route.o \
 			$(OBJ_DIR_SYSTEM)/cpuinfo.o $(OBJ_DIR_SYSTEM)/memory.o $(OBJ_DIR_SYSTEM)/storage.o $(OBJ_DIR_SYSTEM)/display.o \
 			$(OBJ_DIR_SYSTEM)/pci.o $(OBJ_DIR_SYSTEM)/power.o $(OBJ_DIR_SYSTEM)/system.o $(OBJ_DIR_SYSTEM)/virt.o
diff --git a/config.sh b/config.sh
index ea08bc8..198a342 100755
--- a/config.sh
+++ b/config.sh
@@ -7,47 +7,41 @@ RED='\033[0;31m'
 YELLOW='\033[33m'
 NC='\033[0m'
 
-# letting the user choose a theme to compile with
+# Define theme colors
+declare -A THEMES=(
+    ["red"]="-DRED"
+    ["green"]="-DGREEN"
+    ["yellow"]="-DYELLOW"
+    ["magenta"]="-DMAGENTA"
+)
+
+# Letting the user choose a theme to compile with
 if [ "$1" == "--color" ]; then
-case $2 in
-    red)
-        CFLAGS+=" -DRED"
-        echo -e "Theme $2: ${GREEN}OK${NC}"
-    ;;
-    green)
-        CFLAGS+=" -DGREEN"
-        echo -e "Theme $2: ${GREEN}OK${NC}"
-    ;;
-    yellow)
-        CFLAGS+=" -DYELLOW"
+    if [[ -v THEMES[$2] ]]; then
+        CFLAGS+=" ${THEMES[$2]}"
         echo -e "Theme $2: ${GREEN}OK${NC}"
-    ;; 
-    magenta)
-        CFLAGS+=" -DMAGENTA"
-        echo -e "Theme $2: ${GREEN}OK${NC}"
-        ;;
-    *)
-        CFLAGS+="-DDEFALT"
+    else
+        CFLAGS+="-DDEFAULT"
         echo -e "Theme $2: ${RED}Unsupported${NC}"
-        echo -e "${YELLOW}Warning: color defaulting green light${NC}"
-esac
+        echo -e "${YELLOW}Warning: color defaulting to green light${NC}"
+    fi
 fi
 # enable debugging by tunning compiler debugging optimization
 # and debugging symbols
-#otherwise just enable compiler 
+# Enable debugging by tuning compiler debugging optimization and debugging symbols
 if [ "$1" == "--debug" ] || [ "$1" == "-d" ]; then 
     echo -e "Debugging: ${GREEN}ON${NC}"
-    CFLAGS+="-Og -g -DDEBUG"
+    CFLAGS+=" -Og -g -DDEBUG"
     if [ "$2" == "--sanitize" ] || [ "$2" == "-s" ]; then
         CFLAGS+=" -fsanitize=address"
-        LDFLAGS+="-fsanitize=address"
+        LDFLAGS+=" -fsanitize=address"
         echo -e "Sanitizer: ${GREEN}ON${NC}"
     else 
         echo -e "Sanitizer: ${RED}OFF${NC}"
     fi
 else 
     CFLAGS+=" -O2"
-    LDFLAGS+=" -flto" # link time optimization
+    LDFLAGS+=" -flto" # Link time optimization
 fi
 # Libraries to check
 LIBS=("libudev" "libsystemd" "libwayland")
@@ -55,21 +49,35 @@ LIBPCI="libpci"
 
 # Check for the standard libraries
 for LIB in "${LIBS[@]}"; do
-    if [ "$LIB" == "libudev" ] && [ -f /usr/include/libudev.h ]; then
-        CFLAGS+=" -DLIBUDEV"
-        LDFLAGS+=" -ludev"
-        echo -e "checking ${LIB}: ${GREEN}OK${NC}"
-    elif [ "$LIB" == "libsystemd" ] && [ -d /usr/include/systemd ]; then
-        CFLAGS+=" -DSYSTEMD"
-        LDFLAGS+=" -lsystemd"
-        echo -e "checking ${LIB}: ${GREEN}OK${NC}"
-    elif [ "$LIB" == "libwayland" ] && [ -f /usr/include/wayland-client.h ]; then
-        CFLAGS+=" -DLIBWAYLAND"
-        LDFLAGS+=" -lwayland-client"
-        echo -e "checking ${LIB}: ${GREEN}OK${NC}"
-    else
-        echo -e "checking ${LIB}: ${RED}NO${NC}"
-    fi
+    case $LIB in
+        "libudev")
+            if [ -f /usr/include/libudev.h ]; then
+                CFLAGS+=" -DLIBUDEV"
+                LDFLAGS+=" -ludev"
+                echo -e "Checking ${LIB}: ${GREEN}OK${NC}"
+            else
+                echo -e "Checking ${LIB}: ${RED}NO${NC}"
+            fi
+            ;;
+        "libsystemd")
+            if [ -d /usr/include/systemd ]; then
+                CFLAGS+=" -DSYSTEMD"
+                LDFLAGS+=" -lsystemd"
+                echo -e "Checking ${LIB}: ${GREEN}OK${NC}"
+            else
+                echo -e "Checking ${LIB}: ${RED}NO${NC}"
+            fi
+            ;;
+        "libwayland")
+            if [ -f /usr/include/wayland-client.h ]; then
+                CFLAGS+=" -DLIBWAYLAND"
+                LDFLAGS+=" -lwayland-client"
+                echo -e "Checking ${LIB}: ${GREEN}OK${NC}"
+            else
+                echo -e "Checking ${LIB}: ${RED}NO${NC}"
+            fi
+            ;;
+    esac
 done
 
 # detect selinux differently
@@ -80,45 +88,42 @@ if [ -d "/sys/kernel/security/apparmor" ]; then
     CFLAGS+=" -DAPPARMOR_H"
 fi
 
-libpci_path() {
+# Detect distribution and check for libpci
+detect_distribution() {
     local path="$1"
-    # Check for libpci independently
     if [ -d "${path}/pci" ]; then
         CFLAGS+=" -DLIBPCI"
         LDFLAGS+=" -lpci"
-        echo -e "checking libpci: ${GREEN}OK${NC}"
+        echo -e "Checking libpci: ${GREEN}OK${NC}"
     else
-        echo -e "checking libpci: ${RED}NO${NC}"
+        echo -e "Checking libpci: ${RED}NO${NC}"
     fi
 }
 
-# Detect distribution and check for libpci
 if [ -f /usr/bin/apt ]; then
     CFLAGS+=" -DDEBIAN"
-    libpci_path "/usr/include/x86_64-linux-gnu"
+    detect_distribution "/usr/include/x86_64-linux-gnu"
     echo -e "Detected Debian-based distribution: ${GREEN}OK${NC}"
 elif [ -f /usr/bin/rpm ]; then
-    # differentaite b/w opensuse and redhat based distro
-    libpci_path "/usr/include"
+    detect_distribution "/usr/include"
     if [ -f /usr/bin/dnf ]; then
         CFLAGS+=" -DREDHAT"
         echo -e "Detected Redhat-based distribution: ${GREEN}OK${NC}"
     elif [ -f /usr/bin/zypper ]; then
         CFLAGS+=" -DOPENSUSE"
-        echo -e "-Detected Opensuse distribution: ${GREEN}OK${NC}"
+        echo -e "Detected Opensuse distribution: ${GREEN}OK${NC}"
     fi   
 elif [ -f /usr/bin/pacman ]; then
     CFLAGS+=" -DARCH"
-    libpci_path "/usr/include"
+    detect_distribution "/usr/include"
     echo -e "Detected Arch-based distribution: ${GREEN}OK${NC}"
 elif [ -f /usr/bin/emerge ]; then
-    libpci_path "/usr/include"
+    detect_distribution "/usr/include"
     CFLAGS+=" -DGENTOO"
     echo -e "Detected Gentoo-based distribution: ${GREEN}OK${NC}"
 else
     echo -e "${RED}Distribution unsupported${NC}"
 fi
-
 # Check for Flatpak
 if [ -f /usr/bin/flatpak ]; then
     CFLAGS+=" -DFLATPAK"
diff --git a/extra/desktop.c b/extra/desktop.c
index 436d521..a226605 100644
--- a/extra/desktop.c
+++ b/extra/desktop.c
@@ -1,106 +1,42 @@
 #include "../main.h"
-static void get_bash_version(char *version) {
-    FILE *fp= popen("bash -i -c 'echo $BASH_VERSION'", "r");
-    if (!fp) return;
-    if (fgets(version,VERSION_LEN,fp) != NULL) version[strcspn(version, "\n")] = '\0'; 
-    fclose(fp);
-}
-static void get_zsh_version(char* version) {
-    FILE *fp = popen("zsh -i -c 'echo $ZSH_VERSION'", "r");
-    if (!fp) return;
-    if (fgets(version,VERSION_LEN,fp) != NULL) version[strcspn(version, "\n")] = '\0';
-    fclose(fp);
-}
-static void get_fish_version(char *version) {
-    FILE *fp = popen("/usr/bin/fish -c 'echo $version'", "r");
-    if (!fp) {
-        version[0] = '\0';
-        return;
+//detect the compositor we run on this depend on libwayland-client
+// currently worked on gnome mutter and kde kwin.
+enum Compositors compositor;
+
+#ifdef LIBWAYLAND
+static void registry_handler(void *data, struct wl_registry *registry, uint32_t id,
+                             const char *interface, uint32_t version) {
+    // Check the specific interfaces you're interested in
+    if (strcmp(interface, "zwlr_output_manager_v1") == 0) {
+        compositor = SWAY;
+    } else if (strcmp(interface, "kde_output_management_v2") == 0) {
+        compositor = KWIN;
+    } else if (strcmp(interface, "gtk_shell1") == 0) {
+        compositor = MUTTER;
+    } else if (strcmp(interface, "weston_desktop_shell") == 0) {
+        compositor = WESTON;
     }
-    if (fgets(version, VERSION_LEN, fp) != NULL)
-        version[strcspn(version, "\r\n")] = '\0';  // Remove newlines
-    fclose(fp);
 }
 
-static void get_shell_type_comm(enum Shell *sh) {
-    FILE *fp;
-    char content[32],path[MAX_PATH];
+static void registry_remover(void *data, struct wl_registry *registry, uint32_t id) {}
 
-    snprintf(path,sizeof(path),"/proc/%d/comm",getppid());
-    fp = fopen(path,"r");
-    if (!fp) return;
-    if (fgets(content,sizeof(content),fp) == NULL) {fclose(fp); return;}
-    fclose(fp);
-    if (!strcmp(content,"bash\n")) {
-        *sh = Bash;
-    }else if (!strcmp(content,"zsh\n")) {
-        *sh = Zsh;
-    } else if (!strcmp(content,"fish\n")) {
-        *sh = Fish;
-    } else if (!strcmp(content,"csh\n"))
-    {
-        *sh = Csh;
-    }
-    
-}
-static void get_shell_type(enum Shell *sh) {
-    DIR *dp;
-    struct dirent *entry;
-    FILE *fp;
-    char path[96],content[64];
-    int pid;
-    // if there is no debugger we don't need to waste our time searching for all processes so assume the shell is the parent
-    if (!is_debugger_present()) {
-        get_shell_type_comm(sh);
-        return;
-    }
+static const struct wl_registry_listener registry_listener = {
+    registry_handler,
+    registry_remover
+};
 
-    dp = opendir("/proc");
-    if (!dp) return;
-    while ((entry = readdir(dp)) != NULL) {
-        if (entry->d_name[0] == '.') continue;
-        if(!is_pid_directory(entry->d_name)) continue;
-        #ifdef DEBUG
-        pid = atoi(entry->d_name);
-        #endif
-        snprintf(path,sizeof(path),"/proc/%d/comm",pid);
-        fp = fopen(path,"r");
-        if (!fp) continue;
-        if (fgets(content,sizeof(content),fp) == NULL) {fclose(fp); continue;}
-        fclose(fp);
-        if (!strcmp(content,"bash\n")) {
-            *sh = Bash;
-            break;
-        } else if (!strcmp(content,"zsh\n")) {
-            *sh = Zsh;
-            break;
-        } else if (!strcmp(content,"fish\n")) {
-            *sh = Fish;
-            break;
-        } else if (!strcmp(content,"csh\n")) {
-            *sh = Csh;
-            break;
-        }
-    }
-    closedir(dp);
-}
+void detect_compositor() {
+    struct wl_display *display = wl_display_connect(NULL);
+    if (!display) return;
 
-void get_shell_version(char *version, enum Shell *sh) {
-    char* env;
-    get_shell_type(sh);
-    switch (*sh) {
-        case Bash:
-            get_bash_version(version);
-            break;
-        case Fish:
-            get_fish_version(version);
-            break;
-        case Csh:
-        case Zsh:
-            get_zsh_version(version);
-            break;
-    }
+    struct wl_registry *registry = wl_display_get_registry(display);
+    wl_registry_add_listener(registry, &registry_listener, NULL);
+    wl_display_roundtrip(display);
+
+    wl_registry_destroy(registry);
+    wl_display_disconnect(display);    
 }
+#endif
 
 static void get_kde_version(char* version) {
     FILE *kde;
diff --git a/extra/packages.c b/extra/packages.c
index f635ea0..63a7301 100644
--- a/extra/packages.c
+++ b/extra/packages.c
@@ -147,11 +147,14 @@ void package_manager() {
     #elif ARCH
     packages= count_pacman_packages();
     printf("%d (pacman) ",packages);
+    #else
+    return;
     #endif
+
     #ifdef FLATPAK
     printf("%d (flatpak)\n",flatpak);
     #else
-    printf("\n");//make sure to always end newline
+    printf("\n");   
     #endif
     
 }
diff --git a/extra/process.c b/extra/process.c
index 6e531fe..d24b7b2 100644
--- a/extra/process.c
+++ b/extra/process.c
@@ -377,27 +377,28 @@ static int processinfo_interval(int pid, time_t seconds, ProcessInfo *info,struc
     strncpy(info->pcomm,after.pcomm,sizeof(info->pcomm));
     return 0;
 }
-void getProcessInfo(int pid,unsigned int interval) {
+void getProcessInfo(int pid, unsigned int interval) {
     printf(ANSI_COLOR_YELLOW "Getting process info...\n" ANSI_COLOR_RESET);
 
     ProcessInfo info = {0};
     struct cpu_times times = {0};
     double uptime, idletime;
-    //only call those functions if interval is zero
+
     if (!interval) {
         if (readUptime(&uptime, &idletime) != 0) {
-        perror("Error opening /proc/uptime");
-        return;
+            perror("Error opening /proc/uptime");
+            return;
         }
-        int stat = readProcessStats(pid,&info);
+        int stat = readProcessStats(pid, &info);
         if (stat == -1) {
-            fprintf(stderr,ANSI_COLOR_RED "process %d not found\n"ANSI_COLOR_RESET,pid);
+            fprintf(stderr, ANSI_COLOR_RED "Process %d not found\n" ANSI_COLOR_RESET, pid);
             return;
         } else if (stat == 1) {
-            fprintf(stderr,"failed to get parent process command\n");
+            fprintf(stderr, "Failed to get parent process command\n");
         }
-        calculateCPUInfo(&info,uptime,NULL);
+        calculateCPUInfo(&info, uptime, NULL);
     }
+
     if (readMemoryInfo(pid, &info) != 0) {
         perror("Error reading /proc/<pid>/statm");
         return;
@@ -413,20 +414,24 @@ void getProcessInfo(int pid,unsigned int interval) {
         perror("Error reading cgroup");
         return;
     }
-    if (get_ctxt_switches(&info,pid)) {
-        fprintf(stderr,"error reading /proc/%d/status",pid);
+
+    if (get_ctxt_switches(&info, pid)) {
+        fprintf(stderr, "Error reading /proc/%d/status", pid);
         return;
     }
-    get_uid_gid(&info,pid);
+
+    get_uid_gid(&info, pid);
+
     if (interval) {
-        int stat = processinfo_interval(pid,(long)interval,&info,&times);
+        int stat = processinfo_interval(pid, (long)interval, &info, &times);
         if (stat == -1) {
-            fprintf(stderr,ANSI_COLOR_RED "Error: couldn't read process at interval %u\n"ANSI_COLOR_RESET,interval);
+            fprintf(stderr, ANSI_COLOR_RED "Error: couldn't read process at interval %u\n" ANSI_COLOR_RESET, interval);
             return;
         } else if (stat == 1) {
-            fprintf(stderr,ANSI_COLOR_YELLOW "Warning: couldn't get parent process command\n"ANSI_COLOR_RESET);
+            fprintf(stderr, ANSI_COLOR_YELLOW "Warning: couldn't get parent process command\n" ANSI_COLOR_RESET);
         }
-        calculateCPUInfo(&info, uptime,&times);
+        calculateCPUInfo(&info, uptime, &times);
     }
-    printProcessInfo(&info,pid);
+
+    printProcessInfo(&info, pid);
 }
diff --git a/extra/security.c b/extra/security.c
index b1c5d56..3ec4807 100644
--- a/extra/security.c
+++ b/extra/security.c
@@ -76,7 +76,7 @@ static void selinux(void) {
             printf("SELinux:\t" ANSI_COLOR_YELLOW "permissive\n" ANSI_COLOR_RESET);
         }
     } else {
-        perror("fgets /sys/fs/selinux/enforce");
+        perror("Error reading /sys/fs/selinux/enforce");
     }
     fclose(state_file);
 
@@ -101,12 +101,10 @@ static void selinux(void) {
 }
 
 static void apparmor(void) {
-    char *buffer=NULL;
-    unsigned int count=0,estate=0,cstate=0;
-    char profile[SIZE],state[SIZE];
+    char *buffer = NULL;
+    unsigned int count = 0, estate = 0, cstate = 0;
+    char profile[SIZE], state[SIZE];
     size_t size;
-    bool is_loaded;
-    bool enabled = is_apparmor_enabled(&is_loaded);
 
     if (is_apparmor_enabled(NULL)) { // this time loaded and enabled
         printf("Apparmor:\t"ANSI_COLOR_GREEN "enabled\n"ANSI_COLOR_RESET);
@@ -114,24 +112,24 @@ static void apparmor(void) {
         return;
     }
 
-    FILE *fp= fopen("/sys/kernel/security/apparmor/profiles","r");
+    FILE *fp = fopen("/sys/kernel/security/apparmor/profiles", "r");
     if (fp == NULL) {
-        fprintf(stderr,ANSI_COLOR_RED "couldn't open /sys/kernel/security/apparmor %s\n" ANSI_COLOR_RESET ,strerror(errno));
+        fprintf(stderr, ANSI_COLOR_RED "couldn't open /sys/kernel/security/apparmor %s\n" ANSI_COLOR_RESET, strerror(errno));
         return;
     }
-    while (getline(&buffer,&size,fp) != -1) {
+    while (getline(&buffer, &size, fp) != -1) {
         count++;
         if (sscanf(buffer, "%[^ ] (%[^)])", profile, state) == 2) {
-            if (!strcmp(state,"enforce")) {
+            if (!strcmp(state, "enforce")) {
                 estate++;
-            } else if (!strcmp(state,"complain")) {
+            } else if (!strcmp(state, "complain")) {
                 cstate++;
             }
         }
     }
-    printf("\t\tprofiles:\t %d\n",count);
-    printf("\t\tenforce:\t %d\n",estate);
-    printf("\t\tcomplain:\t %d\n\n",cstate);
+    printf("\t\tprofiles:\t %d\n", count);
+    printf("\t\tenforce:\t %d\n", estate);
+    printf("\t\tcomplain:\t %d\n\n", cstate);
     free(buffer);
     fclose(fp);
 }
@@ -142,28 +140,28 @@ void LinuxSecurityModule(void) {
     apparmor();
     //also check for others
     char buf[64];
-    FILE *fp = fopen("/sys/kernel/security/lsm","r");
+    FILE *fp = fopen("/sys/kernel/security/lsm", "r");
     if (!fp) {
-        fprintf(stderr,ANSI_COLOR_RED "failed to open /sys/kernel/security/lsm\n"ANSI_COLOR_RESET);
+        fprintf(stderr, ANSI_COLOR_RED "failed to open /sys/kernel/security/lsm\n" ANSI_COLOR_RESET);
         return;
     }
-    if (fgets(buf,sizeof(buf),fp) != NULL) {
+    if (fgets(buf, sizeof(buf), fp) != NULL) {
         if (strstr(buf, "landlock")) {
             printf("Landlock\t" ANSI_COLOR_GREEN "enabled\n" ANSI_COLOR_RESET);
         } else 
-        if (strstr(buf, "bpf")) {
+if (strstr(buf, "bpf")) {
             printf("BPF\t\t" ANSI_COLOR_GREEN "enabled\n"ANSI_COLOR_RESET);
         }
-        if (strstr(buf, "tomoyo")) {
+if (strstr(buf, "tomoyo")) {
             printf("Tomoyo\t\t" ANSI_COLOR_GREEN "enabled\n"ANSI_COLOR_RESET);
         }
-        if (strstr(buf, "capability")) {
+if (strstr(buf, "capability")) {
             printf("Capability\t" ANSI_COLOR_GREEN "enabled\n"ANSI_COLOR_RESET);
         }
-        if (strstr(buf, "lockdown")) {
+if (strstr(buf, "lockdown")) {
             printf("Lockdown\t" ANSI_COLOR_GREEN "enabled\n"ANSI_COLOR_RESET);
         }
-        if (strstr(buf, "yama")) {
+if (strstr(buf, "yama")) {
             printf("Yama\t\t" ANSI_COLOR_GREEN "enabled\n"ANSI_COLOR_RESET);
         }
     }
@@ -187,4 +185,4 @@ int GetSecureBootStatus() {
     }
     close(fd);
     return 0;
-} 
+}
diff --git a/extra/utils.c b/extra/utils.c
index 37522a7..cb745dc 100644
--- a/extra/utils.c
+++ b/extra/utils.c
@@ -1,22 +1,20 @@
 #include "../main.h"
 
 #define LENGTH 1024 //used by get_pci_info
-int process_file(char *path,char *filename) {
-    printf(DEFAULT_COLOR "%-20s: " ANSI_COLOR_RESET ,filename );
-    FILE *file= fopen(path,"r");
+int process_file(const char *path, const char *filename) {
+    printf(DEFAULT_COLOR "%-20s: " ANSI_COLOR_RESET, filename);
+    FILE *file = fopen(path, "r");
     char file_buff[MAX_LINE_LENGTH];
-    if (file == NULL) {
-        fprintf(stderr,"couldn't open the file");
+    if (!file) {
+        fprintf(stderr, "Couldn't open the file: %s\n", path);
         return 1;
     }
-    while (fgets(file_buff,sizeof(file_buff),file) != NULL) {
+    while (fgets(file_buff, sizeof(file_buff), file) != NULL) {
         file_buff[strcspn(file_buff, "\n")] = '\0';
-        //printf("%-500s\n",file_buff);
         printf("%s\n", file_buff); 
     }
     fclose(file);
     return 0;
-
 }
 
 int is_pid_directory(const char *name) {
@@ -78,7 +76,10 @@ bool is_debugger_present() {
 
     snprintf(path, sizeof(path), "/proc/%d/status", getpid());
     fp = fopen(path, "r");
-    if (!fp) return false;
+    if (!fp) {
+        perror("Error opening /proc/<pid>/status");
+        return false;
+    }
 
     while (getline(&content, &len, fp) != -1) {
         if (strncmp(content, "TracerPid:", 10) == 0) {
diff --git a/include/desktop.h b/include/desktop.h
index 4d78273..b046eea 100644
--- a/include/desktop.h
+++ b/include/desktop.h
@@ -11,13 +11,22 @@ typedef enum {
     MATE,
     NONE
 } Desktop;
+Desktop Detect_desktop(char* version);
 
 enum Protocol {
     WAYLAND,
     X11
 };
-Desktop Detect_desktop(char* version);
-
+enum Compositors {
+    KWIN,
+    MUTTER,
+    WESTON,
+    SWAY,
+};
+extern enum Compositors compositor;
+#ifdef LIBWAYLAND
+void detect_compositor();
+#endif
 
 struct output_info {
     int x, y;
diff --git a/include/process.h b/include/process.h
index dbc6d10..93768ae 100644
--- a/include/process.h
+++ b/include/process.h
@@ -46,7 +46,7 @@ struct cpu_times {
     unsigned long long guest_nice_ticks;
     unsigned long total_ticks;
 };
-int process_file(char *path,char *filename);
+
 void getProcessInfo(int pid,unsigned int interval);
 
 int is_pid_directory(const char *name);
diff --git a/include/utils.h b/include/utils.h
index ab8e3bf..1bab7b4 100644
--- a/include/utils.h
+++ b/include/utils.h
@@ -9,9 +9,12 @@
     functions implemented on extra/utils.c
 
 */
-int process_file(char *path,char *filename);
+int process_file(const char *path, const char *filename);
 
-//check if debugger is present
+/**
+ * @brief Checks if the current process is being debugged.
+ * @return true if the process is being debugged, false otherwise.
+ */
 bool is_debugger_present();
 //used by main.c:Systeminfo
 int is_pid_directory(const char *name);
diff --git a/main.c b/main.c
index df41fa3..a76443e 100644
--- a/main.c
+++ b/main.c
@@ -219,49 +219,60 @@ static void print_load_average() {
 }
 
 static void print_desktop_environment() {
-    char *env,shell_info[VERSION_LEN];
+    char *env, shell_info[VERSION_LEN];
     char version[VERSION_LEN];
     Desktop desktop;
     enum Shell sh;
 
-    if ((env = getenv("XDG_SESSION_TYPE"))) {
-        printf(DEFAULT_COLOR "Session Type:\t" ANSI_COLOR_RESET "%s\n",env);
-    }   
-    if (env && !strcmp(env,"tty")) { 
-        get_shell_version(shell_info,&sh);
-        printf(DEFAULT_COLOR "Shell:\t\t"ANSI_COLOR_RESET "%s %s\n",(sh == Bash ? "Bash":
-                                                                 sh == Zsh ? "Zsh":
-                                                                 sh == Csh ? "Csh":
-                                                                 sh == Fish ? "Fish": "Unknown"),shell_info);
-        
-        return; // there is no much to be done so just return
-    } 
+    env = getenv("XDG_SESSION_TYPE");
+    if (env) {
+        printf(DEFAULT_COLOR "Session Type:\t" ANSI_COLOR_RESET "%s ", env);
+        if (!strcmp(env, "wayland")) {
+            #ifdef LIBWAYLAND
+            detect_compositor();
+            #endif
+            printf("(%s)\n", (compositor == SWAY ? "Sway" :
+                             compositor == KWIN ? "Kwin" :
+                             compositor == MUTTER ? "Mutter" :
+                             compositor == WESTON ? "Weston" : ""));
+        } else {
+            printf("\n");
+        }
+    }
+
+    get_shell_version(shell_info, &sh);
+    printf(DEFAULT_COLOR "Shell:\t\t" ANSI_COLOR_RESET "%s %s\n", (sh == Bash ? "Bash":
+                                                                   sh == Zsh ? "Zsh" :
+                                                                   sh == Fish ? "Fish" :
+                                                                   sh == Csh ? "Csh" : ""), shell_info);
     #ifdef LIBWAYLAND
-    if (env && !strcmp(env,"wayland")) {
+    if (env && !strcmp(env, "wayland")) {
         get_display_model(WAYLAND);
-        printf(DEFAULT_COLOR"Display:\t"ANSI_COLOR_RESET "%s %dx%d %d Hz\n",out_info.make,out_info.width,out_info.height,out_info.refresh_rate/ 1000);
+        printf(DEFAULT_COLOR "Display:\t" ANSI_COLOR_RESET "%s %dx%d %d Hz\n", out_info.make, out_info.width, out_info.height, out_info.refresh_rate / 1000);
+        free(out_info.make); // allocated by get_display_model using strdup  
+        free(out_info.model); // allocated by get_display_model using strdup
     }
-    #endif 
+    #endif
 
-     desktop = Detect_desktop(version);
+    desktop = Detect_desktop(version);
     switch (desktop) {
         case GNOME:
-            printf(DEFAULT_COLOR"Desktop:\t"ANSI_COLOR_RESET "Gnome %s\n",version);
+            printf(DEFAULT_COLOR "Desktop:\t" ANSI_COLOR_RESET "Gnome %s\n", version);
             break;
         case KDE:
-            printf(DEFAULT_COLOR"Desktop:\t"ANSI_COLOR_RESET "KDE %s\n",version);
+            printf(DEFAULT_COLOR "Desktop:\t" ANSI_COLOR_RESET "KDE %s\n", version);
             break;
         case XFCE:
-            printf(DEFAULT_COLOR"Desktop:\t"ANSI_COLOR_RESET "XFCE %s\n",version);
+            printf(DEFAULT_COLOR "Desktop:\t" ANSI_COLOR_RESET "XFCE %s\n", version);
             break;
         case MATE:
-            printf(DEFAULT_COLOR"Desktop:\t"ANSI_COLOR_RESET "Mate %s",version);
+            printf(DEFAULT_COLOR "Desktop:\t" ANSI_COLOR_RESET "Mate %s", version);
             break;
         case NONE:
+            break;
     }
 }
 
-
 static void print_locales_info() {
     char timezone[20],buffer[80],*env;
     struct tm *tm;
diff --git a/system/cpuinfo.c b/system/cpuinfo.c
index 2e12b2f..4d61c53 100644
--- a/system/cpuinfo.c
+++ b/system/cpuinfo.c
@@ -300,39 +300,28 @@ static int get_cpu_sockets() {
     sockets = atoi(buffer);
     return sockets +1;
 }
+static void print_cache_info(int cores);
 void cpuinfo() {
-        printf(ANSI_COLOR_YELLOW "getting processor information\n" ANSI_COLOR_RESET);
-    
-    /*
-        cpuinfo_buffer holds the buffer of the cpuinfo file
-        buffer_size is the size of the buffer
-        processors and cores are strings searched in  the file
-        
-    */     
+    printf(ANSI_COLOR_YELLOW "getting processor information\n" ANSI_COLOR_RESET);
+
     unsigned int sockets = get_cpu_sockets(); 
-    int cores=0,processors=0,level=4; //assumption: 4 cache levels
-    char spath[60],tpath[60];
-    char size_cont[20],type_cont[30];
-    if (count_processor(&cores,&processors)) {
-        printf(DEFAULT_COLOR "cores:\t\t\t"ANSI_COLOR_RESET "%d\n",cores);
-        printf(DEFAULT_COLOR "processor:\t\t" ANSI_COLOR_RESET "%d\n",processors);
+    int cores = 0, processors = 0;
+    if (count_processor(&cores, &processors)) {
+        printf(DEFAULT_COLOR "cores:\t\t\t" ANSI_COLOR_RESET "%d\n", cores);
+        printf(DEFAULT_COLOR "processor:\t\t" ANSI_COLOR_RESET "%d\n", processors);
     }
-    
-    printf(DEFAULT_COLOR"Sockets:\t\t"ANSI_COLOR_RESET "%d\n",sockets);
-    //frequency got via sysfs as 
+    printf(DEFAULT_COLOR "Sockets:\t\t" ANSI_COLOR_RESET "%d\n", sockets);
+
     if (!is_hypervisor_present()) {
-        struct freq frq= frequency();
-        float max= frq.max_freq / 1e6; // 1e6 = 1000000.0
-        float min = frq.min_freq / 1e3; // 1e3= 1000   
+        struct freq frq = frequency();
+        float max = frq.max_freq / 1e6; // 1e6 = 1000000.0
+        float min = frq.min_freq / 1e3; // 1e3 = 1000   
         float base = frq.base_freq / 1e6; // 1e6 = 1000000.0
-        printf(DEFAULT_COLOR "Frequency:\t\t"ANSI_COLOR_RESET "max: %.1f GHz  min: %.1f MHz  base: %.1f GHz\n", max,min,base);
+        printf(DEFAULT_COLOR "Frequency:\t\t" ANSI_COLOR_RESET "max: %.1f GHz  min: %.1f MHz  base: %.1f GHz\n", max, min, base);
     }
-    //temperature
+
     #ifdef supported    
-    // now getting the vendor 
     cpuid();
-    //now we are going to print the brand using cpuid instruction
-    
     char brand[50];
     for (int i = 0; i < 3; ++i) {
         __get_cpuid(0x80000002 + i, &eax, &ebx, &ecx, &edx);
@@ -342,46 +331,51 @@ void cpuinfo() {
         memcpy(brand + i * 16 + 12, &edx, 4);
     }
     brand[48] = '\0';
-    printf(DEFAULT_COLOR "\nBrand:\t\t\t"ANSI_COLOR_RESET  "%s\n", brand);
-    // cpu family stepping and model
+    printf(DEFAULT_COLOR "\nBrand:\t\t\t" ANSI_COLOR_RESET "%s\n", brand);
+
     __get_cpuid(1, &eax, &ebx, &ecx, &edx);
-    
     unsigned int family = ((eax >> 8) & 0x0F) + ((eax >> 20) & 0xFF);
     unsigned int model = ((eax >> 4) & 0x0F) + ((eax >> 12) & 0xF0);
     unsigned int stepping = eax & 0x0F;
-    printf(DEFAULT_COLOR"Family\t\t\t"ANSI_COLOR_RESET "%u\n",family);
-    printf(DEFAULT_COLOR"Model\t\t\t"ANSI_COLOR_RESET "%u\n",model);
-    printf(DEFAULT_COLOR"Stepping\t\t"ANSI_COLOR_RESET "%u\n",stepping);
+    printf(DEFAULT_COLOR "Family\t\t\t" ANSI_COLOR_RESET "%u\n", family);
+    printf(DEFAULT_COLOR "Model\t\t\t" ANSI_COLOR_RESET "%u\n", model);
+    printf(DEFAULT_COLOR "Stepping\t\t" ANSI_COLOR_RESET "%u\n", stepping);
     #else
-        struct Cpuinfo cpu;
-        generic_cpuinfo(&cpu);
-        printf(DEFAULT_COLOR "\nVendor:\t\t\t"ANSI_COLOR_RESET  "%s", cpu.vendor);
-        printf(DEFAULT_COLOR "\nBrand:\t\t\t"ANSI_COLOR_RESET  "%s\n", cpu.model_name);
-        printf(DEFAULT_COLOR"Family\t\t\t"ANSI_COLOR_RESET "%u\n",cpu.family);
-        printf(DEFAULT_COLOR"Model\t\t\t"ANSI_COLOR_RESET "%u\n",cpu.model);
-        printf(DEFAULT_COLOR"Stepping\t\t"ANSI_COLOR_RESET "%u\n",cpu.stepping);
+    struct Cpuinfo cpu;
+    generic_cpuinfo(&cpu);
+    printf(DEFAULT_COLOR "\nVendor:\t\t\t" ANSI_COLOR_RESET "%s", cpu.vendor);
+    printf(DEFAULT_COLOR "\nBrand:\t\t\t" ANSI_COLOR_RESET "%s\n", cpu.model_name);
+    printf(DEFAULT_COLOR "Family\t\t\t" ANSI_COLOR_RESET "%u\n", cpu.family);
+    printf(DEFAULT_COLOR "Model\t\t\t" ANSI_COLOR_RESET "%u\n", cpu.model);
+    printf(DEFAULT_COLOR "Stepping\t\t" ANSI_COLOR_RESET "%u\n", cpu.stepping);
     #endif
-    char arch[10],endianess[10];
-    if (get_arch_and_endianess(arch,endianess,10)) {
-        printf(DEFAULT_COLOR "Architecture:\t\t"ANSI_COLOR_RESET "%s-bit\n",arch);
-        printf(DEFAULT_COLOR "Endianess:\t\t" ANSI_COLOR_RESET "%s",endianess);
+
+    char arch[10], endianess[10];
+    if (get_arch_and_endianess(arch, endianess, 10)) {
+        printf(DEFAULT_COLOR "Architecture:\t\t" ANSI_COLOR_RESET "%s-bit\n", arch);
+        printf(DEFAULT_COLOR "Endianess:\t\t" ANSI_COLOR_RESET "%s", endianess);
     }
+
     hwmon();
+    print_cache_info(cores);
+    printf(ANSI_COLOR_BLUE "CPU Vulnerabilities:\n" ANSI_COLOR_RESET);
+    cpu_vulnerabilities();
+}
+
+static void print_cache_info(int cores) {
     unsigned int eax, ebx, ecx, edx;
     unsigned int cache_count = 0;
     unsigned int cache_type, cache_level, cache_size;
     unsigned int ways, partitions, line_size, sets;
-    unsigned int cache_sharing,associativity;
+    unsigned int cache_sharing;
     char unit[4];
 
-
     while (1) {
-        #if defined(__x86_64) || defined(__i386__) // at least do not do anything on other architectures
+        #if defined(__x86_64) || defined(__i386__)
         __cpuid_count(0x4, cache_count, eax, ebx, ecx, edx);
         #endif
-        cache_type = eax & 0x1F; // Bits 0-4: Cache type
+        cache_type = eax & 0x1F;
         if (cache_type == 0) {
-            // Cache type 0 means no more caches
             break;
         }
         cache_level = (eax >> 5) & 0x7;       // Bits 5-7: Cache level (L1, L2, L3, etc.)
@@ -390,24 +384,21 @@ void cpuinfo() {
         line_size = (ebx & 0xFFF) + 1;
         sets = ecx + 1;
         cache_size = ways * partitions * line_size * sets;
-        cache_size /= 1024; // convert size to KiB because convert_unit_size expects size in KiB
+        cache_size /= 1024;
         cache_sharing = ((eax >> 14) & 0xfff);
-        //associativity = ((ebx >> 22) & 0x3FF) +1; // Extract bits 31:22
-        if (cache_sharing == 0) cache_sharing = cores; //if it is zero then they are not sharing
-        if (cache_sharing == 0) cache_sharing = 1; // finally if still zero because cores are zero the last resort is assume 1
+        if (cache_sharing == 0) cache_sharing = cores;
+        if (cache_sharing == 0) cache_sharing = 1;
         unsigned int instance = cores / cache_sharing;
-        if (instance == 0) instance = 1; // If instance is zero, then there is only one instance
+        if (instance == 0) instance = 1;
 
         double converted_size = convert_size_unit((double)cache_size * instance, unit, sizeof(unit));
 
-        printf(DEFAULT_COLOR"\nCache L%d:\t\t"ANSI_COLOR_RESET "type: %s\n\t\t\tsize: %.1f %s\n\t\t\tinstances: %d\n\t\t\tAssociativity: %d-ways\n", cache_level,
+        printf(DEFAULT_COLOR "\nCache L%d:\t\t" ANSI_COLOR_RESET "type: %s\n\t\t\tsize: %.1f %s\n\t\t\tinstances: %d\n\t\t\tAssociativity: %d-ways\n", cache_level,
                 cache_type == 1 ? "Data cache" :
                 cache_type == 2 ? "Instruction cache" :
                 cache_type == 3 ? "Unified cache" : "Unknown",
-                converted_size, unit,instance, ways);
+                converted_size, unit, instance, ways);
 
-        cache_count++; // Move to the next cache
+        cache_count++;
     }
-    printf(ANSI_COLOR_BLUE "CPU Vurnuabilities:\n" ANSI_COLOR_RESET);
-    cpu_vulnerabilities();
 }
diff --git a/system/memory.c b/system/memory.c
index 4e3b155..c430464 100644
--- a/system/memory.c
+++ b/system/memory.c
@@ -1,60 +1,38 @@
 #include "../main.h"
 
-// Get available memory from /proc/meminfo
-static double get_available_memory(char *unit, size_t len) {
+// Get memory information from /proc/meminfo
+static double get_memory_info(const char *key, char *unit, size_t len) {
     FILE *fp;
     char *line = NULL;
     size_t size = 0;
-    double mem_available = 0.0;
+    double value = 0.0;
 
     fp = fopen("/proc/meminfo", "r");
     if (!fp)
         return 0.0;
 
     while (getline(&line, &size, fp) != -1) {
-        if (strncmp("MemAvailable:", line, 13) == 0) {
-            sscanf(line, "MemAvailable: %lf", &mem_available);
+        if (strncmp(key, line, strlen(key)) == 0) {
+            sscanf(line + strlen(key), "%lf", &value);
             break;
         }
     }
     free(line); // Free the buffer allocated by getline
     fclose(fp);
 
-    return convert_size_unit(mem_available, unit, len);
+    return convert_size_unit(value, unit, len);
 }
 
-static double get_used_memory(char *unit, size_t len) {
-    unsigned long total_mem,available;
-    FILE *fp;
-    char *content;
-    size_t size =0;
-    int fields;
-    fp = fopen("/proc/meminfo","r");
-    if (!fp)
-        return 0;
-    while (getline(&content,&size,fp) != -1) {
-        if (!strncmp(content,"MemTotal:",9)) {
-            fields = sscanf(content,"MemTotal: %lu kB",&total_mem);
-            if (fields <1) {
-                fclose(fp);
-                free(content);
-                return 0;
-            }
-        }
+static double get_available_memory(char *unit, size_t len) {
+    return get_memory_info("MemAvailable:", unit, len);
+}
 
-        if (!strncmp("MemAvailable:",content,13)) {
-            fields = sscanf(content,"MemAvailable: %lu kB",&available);
-            if (fields < 1) {
-                fclose(fp);
-                free(content);
-                return 0;
-            }
-        }
-    }
-    fclose(fp);
-    free(content);
-    return convert_size_unit((double)total_mem - available,unit,len);
+static double get_used_memory(char *unit, size_t len) {
+    double total_mem = get_memory_info("MemTotal:", unit, len);
+    double available_mem = get_memory_info("MemAvailable:", unit, len);
+    return total_mem - available_mem;
 }
+
 int memory_info() {
     struct sysinfo mem;
     char unit[7][4]; // Separate units for each value
diff --git a/system/power.c b/system/power.c
index e4c984d..2272241 100644
--- a/system/power.c
+++ b/system/power.c
@@ -6,11 +6,11 @@ static char* get_value(const char* device, const char* file) {
     char path[MAX_PATH];
     char *content = malloc(32);
     if (!content) return NULL;
-
+    
     snprintf(path, sizeof(path), "%s/%s/%s", BATTERY_PATH, device, file);
     fp = fopen(path, "r");
     if (!fp) {
-        fprintf(stderr, "Error: Couldn't open %s\n", path);
+        fprintf(stderr, "Error: Couldn't open %s: %s\n", path, strerror(errno));
         free(content);
         return NULL;
     }
@@ -34,7 +34,7 @@ static int get_value_number(const char* device, const char* file) {
     snprintf(path, sizeof(path), "%s/%s/%s", BATTERY_PATH, device, file);
     fp = fopen(path, "r");
     if (!fp) {
-        fprintf(stderr, "Error: Couldn't open %s\n", path);
+        fprintf(stderr, "Error: Couldn't open %s: %s\n", path, strerror(errno));
         return -1;
     }
 
@@ -57,7 +57,7 @@ static void get_battery(const char* battery) {
     printf(DEFAULT_COLOR "Vendor:\t\t\t" ANSI_COLOR_RESET "%s\n", vendor ? vendor : "Unknown");
 
     // Model
-    model = get_value(battery, "model_name");  // Fixed: model_name is correct
+    model = get_value(battery, "model_name");
     printf(DEFAULT_COLOR "Model:\t\t\t" ANSI_COLOR_RESET "%s\n", model ? model : "Unknown");
 
     // Technology
@@ -92,35 +92,40 @@ static void get_battery(const char* battery) {
     free(serial);
     free(status);
 }
+
 static void get_ac_info(const char* ac) {
     char *type;
     int online;
-    printf(DEFAULT_COLOR"\nDevice:\t\t\t"ANSI_COLOR_RESET "%s\n",ac);
-    type = get_value(ac,"type");
-    printf(DEFAULT_COLOR "type:\t\t\t"ANSI_COLOR_RESET "%s\n",type);
-    online = get_value_number(ac,"online");
-    printf(DEFAULT_COLOR "Online:\t\t\t"ANSI_COLOR_RESET "%s\n",online == 1 ? "yes":
-                                                              online == 0 ? "no": "unknown");
+    printf(DEFAULT_COLOR "\nDevice:\t\t\t" ANSI_COLOR_RESET "%s\n", ac);
+    type = get_value(ac, "type");
+    printf(DEFAULT_COLOR "Type:\t\t\t" ANSI_COLOR_RESET "%s\n", type ? type : "Unknown");
+    online = get_value_number(ac, "online");
+    printf(DEFAULT_COLOR "Online:\t\t\t" ANSI_COLOR_RESET "%s\n",
+           online == 1 ? "Yes" : online == 0 ? "No" : "Unknown");
     free(type);
 }
+
 void print_battery_information() {
     DIR *dir;
     struct dirent *entry;
-    printf(ANSI_COLOR_YELLOW "checking for power devices\n"ANSI_COLOR_RESET);
-    //first we need to make sure if the dirrectory is empty or not so we don't waste time if it already empty
+    printf(ANSI_COLOR_YELLOW "Checking for power devices\n" ANSI_COLOR_RESET);
+
+    // Check if the directory is empty
     if (is_directory_empty(BATTERY_PATH)) {
-        fprintf(stderr,ANSI_COLOR_RED "No power devices detected\n",ANSI_COLOR_RESET);
+        fprintf(stderr, ANSI_COLOR_RED "No power devices detected\n" ANSI_COLOR_RESET);
         return;
     }
+
     dir = opendir(BATTERY_PATH);
     if (!dir) {
-        fprintf(stderr,ANSI_COLOR_RED "Error: could get battery information %s\n"ANSI_COLOR_RESET,strerror(errno));
+        fprintf(stderr, ANSI_COLOR_RED "Error: Couldn't get battery information: %s\n" ANSI_COLOR_RESET, strerror(errno));
         return;
     }
+
     while ((entry = readdir(dir)) != NULL) {
-        if (!strncmp(entry->d_name,"BAT",3)) 
+        if (!strncmp(entry->d_name, "BAT", 3))
             get_battery(entry->d_name);
-        if (!strncmp(entry->d_name,"AC",2))
+        if (!strncmp(entry->d_name, "AC", 2))
             get_ac_info(entry->d_name);
     }
     closedir(dir);
diff --git a/system/storage.c b/system/storage.c
index e6dae20..7131073 100644
--- a/system/storage.c
+++ b/system/storage.c
@@ -67,31 +67,23 @@ static void get_disk(const char* device) {
 
     printf(DEFAULT_COLOR "Model\t\t\t" ANSI_COLOR_RESET);
 
-    if(!strcmp("nvme0n1",device)) {
-        fp = fopen(paths[0],"r");
-        
-        if (fp) {
-            if (fgets(model,sizeof(model),fp) == NULL)
-                strncpy(model,"unknown",sizeof(model));
-            fclose(fp);
-        } else {
-            strncpy(model,"unknown",sizeof(model));
-        }
-
-    } else if (!strcmp("sda",device)) {
-        fp = fopen(paths[1],"r");
-        if (fp) {
-            if (fgets(model,sizeof(model),fp) == NULL)
-                strncpy(model,"unknown",sizeof(model));
-            fclose(fp);
-        } else {
-            strncpy(model,"unknown",sizeof(model));
+    for (int i = 0; i < sizeof(paths) / sizeof(paths[0]); i++) {
+        if (strcmp(device, paths[i] + 11) == 0) { // +11 to skip "/sys/block/"
+            fp = fopen(paths[i], "r");
+            if (fp) {
+                if (fgets(model, sizeof(model), fp) == NULL)
+                    strncpy(model, "unknown", sizeof(model));
+                fclose(fp);
+            } else {
+                strncpy(model, "unknown", sizeof(model));
+            }
+            break;
         }
     }
     model[strlen(model)] = '\n';
-    printf("%s",model);
-
+    printf("%s", model);
 }
+
 static int get_device_uuid(const char *device,char* uuid, size_t size) {
     DIR *dir;
     struct dirent *entry;
@@ -211,16 +203,17 @@ static void process_udev() {
 #endif
 
 void storage(void) {
-        // Additional processing if LIBUDEV is enabled
-#ifdef LIBUDEV
+    // Additional processing if LIBUDEV is enabled
+    #ifdef LIBUDEV
     process_udev();
-#endif
-printf(ANSI_COLOR_BLUE "Disk partitions:\n"ANSI_COLOR_RESET);
+    #endif
+
+    printf(ANSI_COLOR_BLUE "Disk partitions:\n" ANSI_COLOR_RESET);
     // Open the mount points file
     FILE *mtab = setmntent("/etc/mtab", "r");
     if (mtab != NULL) {
         // Print table header
-        printf("%-16s%-16s%-16s% -16s%-16s%-16s%-1s\n",
+        printf("%-16s%-16s%-16s%-16s%-16s%-16s%-1s\n",
                "Device", "Filesystem", "Mountpoint", "Size",
                "Free", "Used", "UUID");
 
@@ -255,16 +248,15 @@ printf(ANSI_COLOR_BLUE "Disk partitions:\n"ANSI_COLOR_RESET);
 
                 // Retrieve UUID if BLKID is enabled
                 char uuid[96];
-                get_device_uuid(entry->mnt_fsname,uuid,sizeof(uuid));
+                get_device_uuid(entry->mnt_fsname, uuid, sizeof(uuid));
                 // Print only if needed
                 if (needed) {
-                    printf("%-15.15s% -15.12s%-15.12s%10.2f %-4s %10.2f %-4s %10.2f %-4s %s\n",
-                            entry->mnt_fsname, entry->mnt_type, entry->mnt_dir,
-                            total_size, unit_total,
-                            free_blocks, unit_free,
-                            used_blocks, unit_used,
-                            uuid ? uuid : "N/A");
-
+                    printf("%-15.15s%-15.12s%-15.12s%10.2f %-4s %10.2f %-4s %10.2f %-4s %s\n",
+                           entry->mnt_fsname, entry->mnt_type, entry->mnt_dir,
+                           total_size, unit_total,
+                           free_blocks, unit_free,
+                           used_blocks, unit_used,
+                           uuid ? uuid : "N/A");
                 }
             }
         }
diff --git a/system/system.c b/system/system.c
index 4aa7d05..512a6ce 100644
--- a/system/system.c
+++ b/system/system.c
@@ -11,60 +11,80 @@ static bool verify_data(const char *data) {
 }
 
 static System_t *dmi_read() {
-    char *sys_files[]= {"bios_vendor","bios_release","bios_date","bios_version",
-    "product_name","product_family","sys_vendor","chassis_vendor"};
+    char *sys_files[] = {"bios_vendor", "bios_release", "bios_date", "bios_version",
+                         "product_name", "product_family", "sys_vendor", "chassis_vendor"};
 
-    char path[SIZE],buffer[SIZE];
+    char path[SIZE], buffer[SIZE];
     char *iterate[8];
-    System_t *system= malloc(sizeof(System_t));
-    for (int i=0;i < sizeof(sys_files) / sizeof(sys_files[0]); i++) {
-        iterate[i] = malloc(1); // pre allocate the memory so strncpy don't dereference a null pointer
-        snprintf(path,SIZE,"/sys/class/dmi/id/%s",sys_files[i]);
-        FILE *sys= fopen(path,"r");
+    System_t *system = malloc(sizeof(System_t));
+    if (!system) {
+        perror("Failed to allocate memory for system");
+        return NULL;
+    }
+
+    for (int i = 0; i < sizeof(sys_files) / sizeof(sys_files[0]); i++) {
+        iterate[i] = malloc(1); // Pre-allocate memory to avoid dereferencing a null pointer
+        if (!iterate[i]) {
+            perror("Failed to allocate memory for iterate");
+            free(system);
+            return NULL;
+        }
+
+        snprintf(path, SIZE, "/sys/class/dmi/id/%s", sys_files[i]);
+        FILE *sys = fopen(path, "r");
         if (sys == NULL) {
-            perror("failed");
+            perror("Failed to open DMI file");
             continue;
         }
-          
-        if (fgets(buffer,SIZE,sys) != NULL) {
-            iterate[i]= realloc(iterate[i],strlen(buffer)+2);
-            strcpy(iterate[i],buffer);
-            fclose(sys);
+
+        if (fgets(buffer, SIZE, sys) != NULL) {
+            iterate[i] = realloc(iterate[i], strlen(buffer) + 2);
+            if (!iterate[i]) {
+                perror("Failed to reallocate memory for iterate");
+                fclose(sys);
+                free(system);
+                return NULL;
+            }
+            strcpy(iterate[i], buffer);
         }
+        fclose(sys);
     }
-    for (int i=0; i<7; i++) {
+
+    for (int i = 0; i < 8; i++) {
         if (!verify_data(iterate[i])) {
-            fprintf(stderr,ANSI_COLOR_RED"Fatal: Encoutered Unexpected error:invalid array index %d\n"ANSI_COLOR_RESET,i);
+            fprintf(stderr, ANSI_COLOR_RED "Fatal: Encountered unexpected error: invalid array index %d\n" ANSI_COLOR_RESET, i);
+            free(system);
             return NULL;
         }
-        
     }
-    strncpy(system->bios_vendor,iterate[0],sizeof(system->bios_vendor));
-    strncpy(system->release,iterate[1],sizeof(system->release));
-    strncpy(system->date,iterate[2],sizeof(system->date));
-    strncpy(system->version,iterate[3],sizeof(system->version));
-    strncpy(system->product_name,iterate[4],sizeof(system->product_name));
-    strncpy(system->product_family,iterate[5],sizeof(system->product_family));
-    strncpy(system->sys_vendor,iterate[6],sizeof(system->sys_vendor));
-    strncpy(system->chassis_vendor,iterate[7],sizeof(system->chassis_vendor));
-    for (int i=0;i<8;i++) {
-        if (iterate[i]) {
-         free(iterate[i]);   
-        }
+
+    strncpy(system->bios_vendor, iterate[0], sizeof(system->bios_vendor));
+    strncpy(system->release, iterate[1], sizeof(system->release));
+    strncpy(system->date, iterate[2], sizeof(system->date));
+    strncpy(system->version, iterate[3], sizeof(system->version));
+    strncpy(system->product_name, iterate[4], sizeof(system->product_name));
+    strncpy(system->product_family, iterate[5], sizeof(system->product_family));
+    strncpy(system->sys_vendor, iterate[6], sizeof(system->sys_vendor));
+    strncpy(system->chassis_vendor, iterate[7], sizeof(system->chassis_vendor));
+
+    for (int i = 0; i < 8; i++) {
+        free(iterate[i]);
     }
+
     return system;
 }
+
 void system_enum() {
-    System_t *system= dmi_read();
+    System_t *system = dmi_read();
     if (system != NULL) {
-       printf(DEFAULT_COLOR "Bios vendor:"ANSI_COLOR_RESET "\t\t%s",system->bios_vendor);
-       printf(DEFAULT_COLOR "Bios: version:"ANSI_COLOR_RESET "\t\t%s\n",system->release);
-       printf(DEFAULT_COLOR "Bios release date:"ANSI_COLOR_RESET "\t%s",system->date);
-       printf(DEFAULT_COLOR "Product Name:"ANSI_COLOR_RESET "\t\t%s",system->product_name);
-       printf(DEFAULT_COLOR "product family:\t\t"ANSI_COLOR_RESET "%s",system->product_family);
-       printf(DEFAULT_COLOR "System vendor"ANSI_COLOR_RESET "\t\t%s",system->sys_vendor);
-       printf(DEFAULT_COLOR "Chassis Vendor"ANSI_COLOR_RESET "\t\t%s",system->chassis_vendor);
-       free(system);
+        printf(DEFAULT_COLOR "Bios vendor:" ANSI_COLOR_RESET "\t\t%s", system->bios_vendor);
+        printf(DEFAULT_COLOR "Bios version:" ANSI_COLOR_RESET "\t\t%s\n", system->release);
+        printf(DEFAULT_COLOR "Bios release date:" ANSI_COLOR_RESET "\t%s", system->date);
+        printf(DEFAULT_COLOR "Product Name:" ANSI_COLOR_RESET "\t\t%s", system->product_name);
+        printf(DEFAULT_COLOR "Product family:" ANSI_COLOR_RESET "\t\t%s", system->product_family);
+        printf(DEFAULT_COLOR "System vendor:" ANSI_COLOR_RESET "\t\t%s", system->sys_vendor);
+        printf(DEFAULT_COLOR "Chassis Vendor:" ANSI_COLOR_RESET "\t\t%s", system->chassis_vendor);
+        free(system);
     }
 }
 
diff --git a/system/virt.c b/system/virt.c
index a9d9ef2..c4c06a7 100644
--- a/system/virt.c
+++ b/system/virt.c
@@ -16,6 +16,7 @@ static bool is_hypervisor_virtualbox() {
         fclose(fp);
         return true; // finally we got something expected :)
     }
+
     fclose(fp);
     return false; // we shouldn't reach here
 }
@@ -25,21 +26,23 @@ static int detect_container() {
     FILE *fp;
     char content[64];
 
-    //fallback methods 
+    //fallback methods
     if (!access("/.dockerenv",F_OK)) return 1; //also this is unquestionable just return without further doing nothing
 
     // on podman /run/.containerenv is enough
     if (!access("/run/.containerenv",F_OK)) return 2;
 
-    //first check on /run/systemd/container
-    fp = fopen("/run/systemd/container","r");
-    if (!fp) return 0; 
+    // Check /run/systemd/container
+    fp = fopen("/run/systemd/container", "r");
+    if (!fp) return 0;
 
-    if (!fgets(content,sizeof(content),fp)) {fclose(fp); return 0;}
+    if (fgets(content, sizeof(content), fp) == NULL) {
+        fclose(fp);
+        return 0;
+    }
 
-    if (!strcmp(content,"docker")) {fclose(fp); return 1;} // this is the most reliable way so without question return true
     fclose(fp);
-    return 0; 
+    return strcmp(content, "docker") == 0 ? 1 : 0;
 }
 Virtualization detect_hypervisor() {
     unsigned int eax,ebx,ecx,edx;
